# 6월 27일

# 카드 구매하기
# https://www.acmicpc.net/problem/11052
# 다이나믹 프로그래밍

# 최대한 비싼 값으로 N개의 카드를 구매해야함.
# 굉장히 점화식 이해가 어렵다 @.@
# i마다 i까지의 경우를 순회하며 최대 값을 체크해야한다. ?.?
# 시간 복잡도 : O(n^2)
# 점화식 : d[n] = max(d[n-i] + p[i])
# i를 1부터 n까지 순회하며 최댓값을 얻어야 함.

# 입력이 4, 1 5 6 7로 입력되었다는 가정하에 순회 로직
# 순회하는 i값을 총 카드의 개수로 보아야 한다.
# i=3이라면 총 카드 3개의 종류에서 3개산 경우를 체크하는 것이다.

# i = 1
#   j = 1
#   d[1] = max(d[1], d[0] + p[1]) -> d[1] = max(0, 1) -> p[1]를 하나 산 가격 저장

# i = 2
#   j = 1
#   d[2] = max(d[2], d[1] + p[1]) -> d[2] = max(0, 2) -> d[1]결과와 p[1] 더하여 p[1]만 2개 구매한 경우로 비교 (p[1] + p[1])
#   j = 2
#   d[2] = max(d[2], d[0] + p[2]) -> d[2] = max(2, 5) -> p[1] 2개산 가격과 p[2] 1개산 가격 비교. (just p[2])

# i = 3
#   j = 1
#   d[3] = max(d[3], d[2] + p[1]) -> d[3] = max(0, 6) -> d[2]에 저장된 최댓값과 p[1] 산 가격 비교. (p[2] + p[1])
#   j = 2
#   d[3] = max(d[3], d[1] + p[2]) -> d[3] = max(6, 6) -> d[1]에 저장된 최댓값과 p[2] 산 가격 비교. (p[1] + p[2])
#   j = 3
#   d[3] = max(d[3], d[0] + p[3]) -> d[3] = max(6, 6) -> p[3] 1개산 가격과 비교 (1+5, 6 똑같다)

# i = 4
#   j = 1
#   d[4] = max(d[4], d[3] + p[1]) -> d[4] = max(0, 7) -> d[3]에 저장된 최댓값과 p[1] 산 가격 비교. (p[2] + p[1] + p[1])
#   j = 2
#   d[4] = max(d[4], d[2] + p[2]) -> d[4] = max(7, 10) -> d[2]에 저장된 최댓값과 p[2] 산 가격 비교. (p[2] + p[2])
#   j = 3
#   d[4] = max(d[4], d[1] + p[3]) -> d[4] = max(10, 7) -> p[1] + p[3]
#   j = 4
#   d[4] = max(d[4], d[0] + p[4]) -> d[4] = max(10, 7) -> just p[4]

# 결론은 i개의 카드를 구매한 최댓값을 Memorization으로 누적시키면서,
# i를 전진시키면서 합을 맞추며 각 카드 팩을 구매하는 경우를 맞추고 최댓값을 갱신해가며 나간다.
# i-j와 j가 이해가 잘 안되었는데,
# d[i-j] + p[j] 여기서 i-j + j는 항상 i가 성립되는 것을 볼 수 있다.
# 즉, 이미 구해진 최댓값에 p[j]를 추가하는 경우 최댓값이 갱신되는지 보기위해 했다고 볼 수 있음.

# 예를 들어 p[1]을 4개 구입, 3개 구입, 2개 구입, 1개 구입, 0개 구입
# 이렇게 모든 경우의 수를 돌며 p[2], p[3], p[4]를 하나씩 넣어주는 Brute Force로 풀었다면
# 시간 복잡도가 어마무시했을 것임. (각 p[i]마다 n-i만큼 구입되는 경우를 포함)

# 각 d[i]의 경우는 i개를 구매하는 카드 팩을 구매했을 경우 최댓값을 가지게 되는 구조이다.

n = int(input())

# n 크기를 맞추기 위해 [0] 배열 추가
p = [0] + list(map(int, input().split(' ')))
d = [0] * (n + 1)

for i in range(1, n + 1):
    for j in range(1, i + 1):
        d[i] = max(d[i], d[i-j] + p[j])

print(d[n])

