2020.8.26(Wed)

# 다이나믹 프로그래밍
큰 문제를 작은 문제로 나눠서 푸는 알고리즘.  
다이나믹 자체에 의미는 없다. (동적이 아님!!)  

DP vs 분할 정복 (divide & conquer)  
두 방법 다 큰 문제를 작게해서 푼다!  
DP는 작은 문제끼리의 중복이 가능함.  
분할 정복은, 작은 문제끼리 중복이 되지 않음

DP 문제의 유형은 아래와 같다.  
- 경우의 수 개수 구하기
- 최솟값 구하기
- 최댓값 구하기
- 최적값 구하기

DP 문제를 잘 분별하기 위해서,  
n에 따라 어떤 경우의 수가 만들어지는지와  
정답을 구하기 위해 모든 경우의 수가 필요한지,  
부분적으로 필요한 것만 있으면 되는지를 잘 판단하자.

## Optimal Substructure
`부분 최적 구조`  
부분 문제로 큰 문제의 해를 구할 수 있는 경우.

## Memoization
이전에 구한 답을 저장하여, 다음 해를 구할 때 사용함.

## 구현 방식
`top-down` : 큰 문제에서 필요한 작은 문제를 찾아 작은 문제 해결...  
주로 재귀 호출로 사용됨.

`bottom-up` : 작은 문제를 해결하여 그 다음 문제 해결 ... 큰 문제 해결  
주로 반복문으로 사용됨.
단점 : 작은 문제부터 큰 문제까지 모든 경우를 다 계산해야한다는 단점 존재함.  

두 방법 다 이용하여 푸는 방법을 연습하는 것을 추천!

## 풀이 전략
`점화식`을 정의해라.  
항상 top-down, bottom-up 둘다 풀 수 있다고 가정하지 말기  
재귀 호출 횟수나, 주어진 n 크기에 따라 다르다!  

# 문제풀이

## 1로 만들기
목표 : N을 1로 만드는 최소 연산 횟수  
연산 종류 : 
1. 3 나누기
2. 2 나누기
3. 1빼기

점화식 : d[n] = min(d[n-1], d[n / 3], d[n / 2])

## 2xn 타일링 문제
목표 : 2xn 직사각형 1x2, 2x1 타일로 채우는 방법  
타일 종류 : 
1. 1x2 하나 배치
2. 2x1 2개 배치

d[0] = 0  
d[1] = 1  
d[2] = 2  

점화식 : d[n] = d[n-1] + d[n-2]

## 2xn 타일링 문제 2
목표 : 2xn 직사각형 1x2, 2x1, 2x2 타일로 채우는 방법  
타일 종류 : 
1. 1x2 하나 배치
2. 2x1 2개 배치
3. 2x2 하나 배치

이전 문제에서 새로운 정사각형 타일이 추가된 방식이다.  
2*1를 2개 배치할 자리에 새로운 것이 추가된 것이므로 d[n-2]를 한번 더 더해주면 된다.  
똑같이 n이 2개 들어가는 자리에 추가될 수 있기 때문이다.

d[0] = 0
d[1] = 1
d[2] = 3

점화식 : d[n] = d[n-1] + d[n-2] + d[n-2]

## 1, 2, 3 더하기
목표 : 정수 n을 1, 2, 3의 합으로 나타내는 방법 수 구하기  
방법
1. 1더하기
2. 2더하기
3. 3더하기

d[0] = 1
d[1] = 1
d[2] = 2
d[3] = 4

점화식 : d[n] = d[n-1] + d[n-2] + d[n-3]

## 카드 구매하기
목표 : 카드 N개를 구매하는 경우의 수 비용의 최대값  

d[n]을 오기 위해서, d[n-1]에서 p[1]를 더한 값도 올 수 있고,
d[n-2]에서 p[2]를 더한 값도 올 수 있다.  
이 경우 중 가장 큰 값이 오는 경우를 찾으면 된다.

점화식 : d[n] = max(d[n], d[n-i] + p[i])

## 카드 구매하기2
목표 : 이전 문제에서 최솟값 구하기  

이전 문제에서 min으로 바꾸면 된다.  
다만, 최솟값이므로 배열의 초기값을 잘 설정해주어야 한다.  
나의 경우는 배열 초기값을 전부 카드 값으로 했기에 문제 없음.

점화식 : d[n] = min(d[n], d[n-i] + p[i])

## 1, 2, 3 더하기 5
목표 : 1, 2, 3 합이지만, 같은 수를 연속으로 사용할 수 없음.  

즉, 2를 나타날 때 1+1을 사용할 수 없다.  
3은 1+1+1을 사용할 수 없고, 1+2와 3만 사용 가능하다.  

1 = 1
2 = 2
3 = 1+2, 3
4 = 1+3, 1+2+1
5 = 2+3, 2+1+2

2차원 배열로, dp[i][j]를 만들어, j를 각각 마지막에 사용한 수를 의미하는 숫자로 초기화한다.  
즉, dp[i][1]은 1을 마지막으로 사용하여 1을 만든 경우 1  
dp[i][2] 2를 마지막으로 사용하여 만든 경우  
dp[i][3] 3를 마지막으로 사용하여 만든 경우로 해서 말이다.  

그렇게 하여, 그 다음 문제를 해결하고 마지막 출력은 dp[i]를 모두 더한 값을 출력하면 될 것이다.  

점화식 (경우의 수 3가지)  
d[n][1] = d[n-1][2] + d[n-1][3]  
d[n][2] = d[n-2][1] + d[n-2][3]  
d[n][3] = d[n-3][1] + d[n-3][2]  

이것 역시, 초기 dp 배열 초기화가 중요하다.

## 쉬운 계산 수
목표 : 인접한 숫자의 차이가 1이나면 계단이 만들어짐, 개단 갯수 구하기  

계단의 예: 45656

1일 때, 1 2 3 4 5 6 7 8 9 총 9가지의 경우가 있다.
여기서 2일 때는 d

점화식 (0이나 9일 때는 경계를 검사하여 -1이나 10을 더하지 않도록)  
i는 0~9까지 검사  
d[n][i] = d[n-1][i-1] + d[n-1][i+1]


## 이친수
0과 1로만 이루어진 이진 수지만,  
1로 시작하며 중간에 1이 연속되어 나타날 수 없는 수.  

1, 10, 100, 101, 1000, 1001은 이친수가 될 수 있다.

0이전에는 1, 0이 모두 올 수 있음  
1이전에는 0밖에 올 수 없음.  
dp를 2차원으로 dp[n][2]선언하여,  
0으로 끝나는 자리에 dp[i][0] 저장하고,  
1은 dp[i][1]에 저장한다.  

점화식 :  
dp[n][0] = dp[n-1][0] + dp[n-1][1]  
dp[n][1] = dp[n-1][0]  

1차원 DP로도 풀 수 있다고 한다.  
dp[n] = dp[n-1] + dp[n-2]  
이것이 가능한 이유는, 경우가 0과 1밖에 없기 때문이다.  
dp[n]에서 0으로 끝나는 것은 항상 dp[n-1]개 만큼 가지고 있고,  
1로 끝나는 것은 항상 dp[n-2]개 만큼 가지고 있게 된다.  

그래서 dp[n-1]에서 0과 1을 붙이면 되니 그 경우의 수와 나머지는 1밖에 못 붙이는 경우인데 dp[n-2]의 경우의 수가 그 개수를 가지고 있으니 그 2개 값을 더하면 된다.

1차원 풀이는 살짝 이해하기가 난해하긴한데...  
n 5까지 경우의 수를 나열하며 조금 살펴보면 편하다.  

1   1  
2   10  
3   100 101  
4   1000 1010 1001  
5   10000 10100 10010 10001 10101  

여기서 5번 케이스를 살펴보면, 
4번 케이스인 1000, 1010, 1001 모두 0을 추가할 수 있다. 근데 여기서, 4번 케이스의 모두가 1을 추가할 순 없다.  
4번 케이스에서 1로 끝나는 것은 2번 케이스 개수만큼 존재한다.  

