* 문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/42890
* 문제 유형 : 2진 비교, 완전 탐색
* 시간 복잡도 : O(2^n)

테이블의 올 수 있는 컬럼의 최대 크기는 8이하이다.
즉, 각 컬럼을 선택하거나 선택하지 않는 경우를 전체 탐색하는데에 2^n의 시간 복잡도가 필요한데
2^8 정도의 크기는 아무렇지도 않다.

이런 알고리즘은 크기 20까지는 그럭저럭 실행해볼만하다.

유일성이 만족하는 경우를 확인한 후
최소성이 만족한다면 저장한다.

최소성은 현재 결과가 이전 결과에 포함 되는지를 보면 되기에,
현재 결과와 이전 결과들을 | (or) 비교 값이 현재 결과가 나왔다면 이전 결과에 포함된 것이다.
이 경우 최소성 불만족.

유일성은 선택된 칼럼의 레코드들이 unique 한지 비교하면 되기에 set 자료구조로 해결 가능.

이 2개가 만족하면 결과에 보관한다.

유일성을 처리할 때, 문자열만을 가지고 유일성을 판단하면 레코드 전체 문자열을 병합하는 과정이 필요하게 된다.
이 과정 속에서 메모리 비용이 꽤나 차지하니, string 값을 hashing해서 유일성을 판단하는 방법도 있다.
다만, hashing해서 판단하면... collision 문제가 있긴한데, 현재 알고리즘 통과에는 문제가 없었다.


# 언어별 특이사항

- C++

string hashing을 위해 hash<string>을 선언해야함.

- Python
tuple 구조로 추가하면 각 요소별로 set에서 구별이 된다. (아주 편해)

- Java
python과는 달리 tuple 구조로 가지고 있어도 set에서 인식이 안되므로,
string을 이어 붙어서 set에서 중복을 구별할 수도 있지만,
각 column 내용의 hash 결과를 계속 누적시켜서 식별할 수도 있다.
hash 결과를 통해 하는 것이 메모리가 훨씬 절약된다.



