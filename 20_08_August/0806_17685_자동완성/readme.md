* 문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/17685
* 문제 유형 : hash, tree 응용
* 시간 복잡도 : O(N)? 하지만 dict 탐색이라 무거운 O(N)

한번 입력된 단어에 대해서 그 다음번 입력 시 자동으로 입력될 수 있는지를 판단해야 한다.

입력 값이 어마어마하므로, 전체 탐색할 생각이라면 time-over

단어의 수는 100,000 그리고 모든 단어 길이 합은 1,000,000을 넘지 않는다.

즉 1단어가 백만길이로 입력될 수는 있다는 뜻이지만, 총 10만개의 단어가 입력된다면,
각 단어는 평균 10개 길이가 될 것이다.

각 알파벳 철자마다 dictionary(hash-map) tree를 만드는 법을 구상해보았다.

예를 들어 go, gone, guild가 있다면

g-o-n-e
 -u-i-l-d

이런 트리가 형성될 것이다. 그리고 단어마다 각 알파벳 트리를 순회하며 매치가 안될 때까지만 순회하여 그 길이를 반환.
다음 철자에 해당하는 노드가 없다면, 바로 탐색이 되는 것이다.

시간 복잡도는 O(N)이 될 것이라 생각.

다행히 무사히 통과함!!

다른 사람의 풀이를 보니, 정렬을 실행한 후 자신의 문자열과 가장 비슷한 자기 다음 문자열을 비교하여 처리하는 것도 봤다.

이것이 가능한 이유는, 정렬을 실행하면 자기 다음 문자열은 자신과 거의 흡사하면서 조금 더 큰 문자열이 뒤에 가기 때문.

즉 이전 문자열이 이후 문자열의 포함이 되는지만 확인하면 되기 때문.

다양한 방법이 있구나 싶다.

정렬도 NlogN의 비용이 들겠지만, tree로 인한 성능적 손실이 없을테니, 성능의 차이를 확인해보았음.
겁나 빠르다.... 거의 10배 넘게 차이가 난다.. 역시 tree로 인한 탐색 오버헤드가 매우 크다고 보임.

# 언어별 특이사항

- C++

- Python

- Java

