* 문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/12983
* 문제 유형 : DP
* 시간 복잡도 : O(N*M) N은 strs 길이 M은 T의 길이

이 문제의 핵심은, 중복되는 경우를 제외하고 최적의 답을 찾아내는 것이다.

종이 조각을 무한정으로 사용할 수 있으니, 이것으로 만들 수 있는 작은 문제들을 중복으로 구한다면 안된다. *time-out

만약 종이 조각이 ap, ple, app, l, e이렇게 있고, 답을 appleappleappleapple을 만들어야 한다면

(ap, ple)로 apple을 2조각으로 만들 수 있고 이를 이용하여 appleapple을 4조각으로 만들 수 있고 즉, appleappleappleapple은 8조각으로 만들 수 있을 것이다.

요즘 DP 문제를 많이 안 풀어서 이런 사고가 많이 굳었나보다.

정말 엄청난 삽집하게 만드는 문제...

DFS, BFS(Atar)를 다 해봐도 역시나 중복되는 탐색을 제거하기 어려웠다.

DP식 사고를 전환해서 아래와 같이 생각해서 풀어봤다.

문자열 t의 인덱스마다 매칭이 되는 strs의 요소를 찾으면, 하나하나 dp를 위한 배열에 얼만큼의 종이를 이용했는지 최솟값을 누적시켜 나가는 방법.

즉, d[n] = min(d[n], d[j] + 1)

각 루프마다 t의 인덱스에 완성시키지 못 했다면 -1을 리턴

이 문제는 딱히, C++과 Java로 구현할 필요가 없다고 생각되어 하지 않았다. (단순 DP 배열 문제..)

피곤하기도 하고, C++과 java로 풀만큼의 영양가가 있는 문제가 아니었다..


# 언어별 특이사항

- C++

- Python

- Java

