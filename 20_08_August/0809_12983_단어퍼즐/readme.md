* 문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/12983
* 문제 유형 : DP
* 시간 복잡도 : O(N*M) N은 strs 길이 M은 T의 길이

요즘 DP 문제를 많이 안 풀어서 이런 사고가 많이 굳었나보다.

정말 엄청난 삽집하게 만드는 문제...

DFS, BFS(Atar)를 다 해봐도 역시나 중복되는 탐색을 제거하기 어려웠다.

DP식 사고를 전환해서 아래와 같이 생각해서 풀어봤다.

탐색 속도를 빠르게 하기 위해 각 strs을 set으로 만들어 사용

문자열 t의 인덱스마다 매칭이 되는 strs의 요소를 찾으면, 하나하나 dp를 위한 배열에 얼만큼의 종이를 이용했는지 최솟값을 누적시켜 나가는 방법.

즉, d[n] = min(d[n], d[n - 1] + 1)

각 루프마다 t의 인덱스에 완성시키지 못 했다면 -1을 리턴


# 언어별 특이사항

- C++

- Python

- Java

