* 문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/42861
* 문제 유형 : 그래프, disjoint_set, 최소 신장 트리
* 시간 복잡도 : O()

모든 정점을 도달 가능한 최소 비용을 요구로하는 간선들의 집합을 구하는 문제.
(최소 신장 트리 알고리즘 구현 문제)

- 크루스칼 알고리즘

모든 간선 비용에 대해 오름차순으로 정렬을 하고,
비용이 작은 간선 순으로 하나하나 꺼내어 모든 정점이 연결될 때까지 반복한다.

여기서, 모든 정점이 연결될 때까지 순환되는 cycle이 생기면 안되므로,
disjoint_set이라는 구조를 이용하여 정점 간의 싸이클이 생기는지 검사한다.

disjoint_set은 간선을 통해 정점이 연결될 때마다 각 정점이 연결된 집합을 표현한다.
그러므로, 2개의 정점이 연결될 때 이미 그 정점들이 같은 set에 있다면 싸이클이 생긴다는 것.

disjoint_set을 구현하기 위한 3개 메서드 (make_set, find, union)
make_set은 모든 set에 대한 초기화 작업으로 각 정점마다 set을 하나씩 생성하면 된다.

예) {a, b, c, d} 4개의 정점이 있는 경우 [{a}, {b}, {c}, {d}]

find는 각 정점이 현재 어느 set에 담겨 있는지 찾는 함수이다.

union은 2개의 set을 합쳐 하나의 set으로 만든다.

예) 위예시 상태에서 {a}와 {b}를 합친 결과 [{a, b}, {c}, {d}]

이렇게 해서 disjoint_set에 1개의 set만 남은 경우 모든 정점이 연결되었다고 볼 수 있음.

- 프림 알고리즘

크루스칼에 비해 조금 더 심플하다. (disjoint set이 필요가 없다.)

임의의 정점하나를 선택해 우선 순위 큐에 코스트가 짧은 순서대로 간선을 집어 넣는다.

큐에서 가장 최소 비용의 간선을 꺼내어 연결 가능한지 확인한다. (현재 연결된 정접이 있는 경우 싸이클이 형성 되므로 생략)

연결된 경우, 해당 정점으로 연결 가능한 간선을 큐에 또 추가한다.

이 과정을 반복하여 모든 정점이 연결되면 종료한다.

# 언어별 특이사항

- C++


- Python



- Java



